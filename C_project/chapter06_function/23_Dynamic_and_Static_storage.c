//
// Created by 郝海程 on 2024/3/30.
//动态存储和静态存储
/*                   涉及的范围                                   生命周期                                存储位置
 *
 *动态存储方式         函数的形参                                   函数使用时加载，函数执行结束后回收
 *                   函数体内的局部变量且不使用static修饰             可以使用auto修饰，也可以省略               动态存储区
 *                   函数的返回地址
 *                   寄存器变量
 *
 *静态存储方式          使用static修饰的；                             整个程序周期
 *                      全局变量
 *
 *
 * */


/*
#include <stdio.h>

void nonStaticFun() {
    int n = 10; //动态存储方式
    printf("n=%d\n", n);
    n++;
    printf("n++=%d\n", n);
}

void staticFun() {
    static int n = 10; //静态存储方式
    printf("static n=%d\n", n);
    n++;
    printf("n++=%d\n", n);
}



int main(void) {
    nonStaticFun();
    staticFun();
    printf("\n");

    nonStaticFun();
    staticFun();
    printf("\n");
    return 0;
}*/
//n=10
//n++=11
//static n=10
//n++=11
//
//n=10
//n++=11
//static n=11
//n++=12
//1、对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。
//
//2、对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行的，每调用一次函数就执行一次赋值语句。


//例2
#include <stdio.h>

int f(int); //函数原型

int main() {
    int a = 2, i; //(自动)局部变量
    for (i = 0; i < 3; i++)
        printf("%d\n", f(a)); //输出f(a)的值

    return 0;
}

int f(int a) {
    auto int b = 0; //(自动)局部变量
    static int c = 3; //静态局部变量
    printf("c = %d\n",c);
    b++;
    c++;
    return (a + b + c);
}
//c = 3
//7
//c = 4
//8
//c = 5
//9

//补充说明：
//
//1、虽然静态局部变量在函数调用结束后仍然存在，但其它函数是不能引用它的。因为它是局部变量，只能被本函数引用，而不能被其它函数引用。
//
//2、如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符′\0′（对字符变量）。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又重新另分配存储单元，而所分配的单元中的内容是不可知的。